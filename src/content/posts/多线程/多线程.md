---
title: 多线程
published: 2025-08-03
description: 多线程相关八股文
image: './多线程.png'
tags: [八股文]
category: Java
draft: false 
lang: ''
---

## 一、多线程的创建方式

1. 继承thread类，重新run方法。
2. 实现Runnable接口，重写run方法。
3. 实现Callable接口。
4. 使用线程池来创建线程。

## 二、ThreadPoolExecutor

ThreadPoolExecutor内部用一个变量来维护两个值：private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0))，高3位保存runState，低29位保存workerCount。

## 1、线程池的核心运行机制

1. 刚开始线程池中无任何线程，此时提交任务，那么当线程池运行状态是RUNNING，且workerCount < corePoolSize,那么创建一个线程去处理任务。
2. 当workerCount = corePoolSize,且阻塞队列未满，那么先将任务添加到阻塞队列中。
3. 当阻塞队列满了，workerCount < maximumPoolSize，那么就会创建非核心线程去执行任务。
4. 当workCount = maximumPoolSize,且队列已满，则根据拒绝策略来处理该任务，默认是直接抛出异常。

## 2、线程池的7大参数

```java
    public ThreadPoolExecutor(int corePoolSize, #核心线程数
                              int maximumPoolSize, #最大线程数
                              long keepAliveTime, #非核心线程存活时间
                              TimeUnit unit, #时间单位
                              BlockingQueue<Runnable> workQueue, #阻塞队列
                              ThreadFactory threadFactory, #线程工厂
                              RejectedExecutionHandler handler #拒绝策略) {
        ...
    }
```

## 3、参数设计准则

1. 一般核心线程数跟最大线程数设置成一样的。因为核心线程数设置的足够合理，这些线程就已经可以充分发挥CPU的性能了，如果再额外的追加一些线程，反而可能会因为CPU的	  上下文切换之类的问题，导致性能变低。
2. 核心线程数的设置需要根据任务情况去考虑。
   --如果是计算密集型，那么推荐设置为CPU核心数+1.
   --如果是I/O密集型，比如说有网络I/O，磁盘I/O,这种推荐为cpu核数*cpu核数*（1+W/C）。W表示等待时间，C表示计算时间。W，C可以通过一些监控工具来估算。如果希		望这个数值可以调整到最佳的数值，还需要再进行压测（JMeter），看看哪个设置的值的吞吐量最高。
3. 工作队列，也叫阻塞队列。用阻塞队列的原因，假如用非阻塞，那么它存满的时候可能会触发扩容，但是我们需要它来触发拒绝策略。线程池里的工作队列中要频繁的增删任务，    LinkedBlockingQueue更适合线程池里的需求。
4. 拒绝策略：一般触发了拒绝策略，我们应该考虑的是是否需要修改某些参数。
   -- Abort：抛异常（默认，可以得到通知）。 
   -- CallerRuns：线程池处理不过来的话，由提交任务的线程自己去处理（并行变串行）。
   -- Discard：任务直接扔了，而且不告诉你。
   -- DiscardOldest：将工作队列排在最前面的任务丢弃掉，重新投递当前任务到线程池。

## 4、动态线程池

其实线程池是支持动态设置的，ThreadPoolExecutor提供了setCorePoolSize(int corePoolSize)，setMaximumPoolSize(int maximumPoolSize)。目前已有开关框架：Hippo4j、dynamictp

附上美团技术团队对线程池的理解：https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html

## 三、CompletableFuture

1. CompletableFuture适合做线程编排，比如A、B、C三个任务，需要按照某种顺序去执行，编排起来方便。

2. 调用入口是runAsync() 或者supplyAsync()方法。其中两者是区别是runAsync()是没有返回结果的，supplyAsync()是有返回结果的。

3. CompletableFuture如果不提供线程池的话，默认使用的ForkJoinPool，而ForkJoinPool内部是守护线程，如果主线程结束了，守护线程会跟着一起结束。

4. 编排相关方法：

   -- thenApply()：A任务处理完后，将结果给任务B，最终返回B的结果。

​       -- thenAccept()：A任务处理完之后，将结果给任务B，B无返回结果。

​       -- thenRun()：A任务没有返回结果，B也不接收A的结果，B也无结果。

5. 还有很多类似的方法，然后内部编排基于栈来实现的，具体看源码。